var cache = {},
  fs = require('fs'),
  args = process.argv,
  util = require('util'),
  cliRoot = './private/cli/',
  readline = require('readline'),
  exec = require('child_process').exec;


function execute(command, callback){
  exec(command, function(error, stdout, stderr){ callback(stdout); });
};

function printError(content, callback) {
  execute('echo $(tput setab 1)$(tput setaf 7) ' + content + ' $(tput sgr0)', function (string) {
    process.stdout.write('\n' + string + '\n');
    callback(string);
  });
}

function printInfo(content) {
  process.stdout.write(util.inspect(content, { colors: true }).replace(/\'/g, '') + '\n');
}

function printCommand(command, description) {
  process.stdout.write(util.inspect(command, { colors: true }).replace(/\'/g, '') + "\t - " + description);
}

function getCreateMethods() {
  if (cache['createMethods']) {
    return cache['createMethods'];
  }

  cache['createMethods'] = fs.readdirSync(cliRoot + 'create/' + configuration.create_profile );
  return cache['createMethods'];
}

function commandExists(command) {
  return commands[command];
}

function quote(regex) {
  return regex.replace(/([()[{*+.$^\\|?])/g, '\\$1');
}

function slugify(text) {
  text = text.replace(/[^-a-zA-Z0-9\s\/\.+]+/ig, '');
  text = text.replace(/\s+/gi, "-");
  return text;
}

function createFoldersAndFile(conf) {
  var absolutePath = '',
    pathParts = conf.path.split('/');

  pathParts.forEach(function (part, index) {
    var isDirectory = false;

    absolutePath += part;

    if (pathParts.length - 1 !== index) {
      absolutePath += '/';
      isDirectory = true;
    }

    if (!fs.existsSync(absolutePath)) {
      if (isDirectory) {
        fs.mkdirSync(absolutePath);
      } else {
        // It has to be the file
        fs.writeFileSync(conf.path, conf.contents, { encoding: 'utf8' });
      }
    }
  });
}

function createFiles(path, variables, filesConfiguration, callback) {
  variables.forEach(function (variable) {
    filesConfiguration.map(function (file) {
      var variableRegExp = new RegExp(quote('**' + variable.name + '**'), 'g');

      file.name = file.name.replace(variableRegExp, variable.value);
      file.path = slugify(file.path.replace(variableRegExp, variable.value));

      file.contents = fs
        .readFileSync(path + '/templates/' + file.template, { encoding: "utf8" })
        .replace(variableRegExp, variable.value)
      ;

      return file;
    })
  });

  filesConfiguration.forEach(function (file) {
    createFoldersAndFile(file);
  });

  callback();
}

/*
 Configuration
 private/cli/configuration.json
 */
var configuration = JSON.parse(fs.readFileSync(cliRoot + 'configuration.json', { encoding: "utf8" }));

/*
 Commands
 create:...
 */
var commands = {};

// Add create commands to the 'commands' object
getCreateMethods().forEach(function (createPart) {
  commands['create:' + createPart] = 'file_contents';
});


// TODO: Rewrite logic to be useable if there were more than 3 arguments

// Process the given input
if (args.length === 3) {
  // If there are exactly 3 arguments (for example "node meteor-boilerplate create:view")
  var command = args[2],
    parts = command.split(':'),
    userInput = [];

  if (commandExists(command)) {
    var rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    // Different kinds of commands
    if (command.substr(0, 6) === 'create') {
      var createPath = cliRoot + 'create/' + configuration.create_profile + '/' + parts[1];

      var createConf = JSON.parse(fs.readFileSync(
        createPath + '/configuration.json',
        { encoding: "utf8" }
      ));

      var variables = createConf.variables;

      var argument = variables.shift();
      console.log(argument.description);

      rl.prompt();

      rl.on('line', function(line) {
        if (!line) {
          console.log('Please enter a value!');
          rl.prompt();
        } else {
          userInput.push({ 'name' : argument.name, 'value' : line });

          if (variables.length === 0) {
            createFiles(createPath, userInput, createConf.files, function () {
              console.log();

              createConf.files.forEach(function (file) {
                process.stdout.write('-- Created ');
                printInfo(file.path );
              });

              console.log();
              process.exit(0);
            });
          }

          argument = variables.shift();

          console.log(argument.description);
          rl.prompt();
        }
      })
    }
  } else {
    printError('The command ' + command + ' has not been found!', function () {
      // TODO: Implement simple suggestions
      // console.log('Did you mean: ');
      process.exit(0);
    });
  }
} else if (args.length > 3) {
  // Expect the exact amount of needed variables to be entered
} else {
  // If no command was entered, print out the overview of commands
  // Our nice title
  console.log("                   __                              __          _ __                __      __     ");
  console.log("   ____ ___  ___  / /____  ____  _____            / /_  ____  (_) /__  _________  / /___ _/ /____ ");
  console.log("  / __ `__ \\/ _ \\/ __/ _ \\/ __ \\/ ___/  ______   / __ \\/ __ \\/ / / _ \\/ ___/ __ \\/ / __ `/ __/ _ \\");
  console.log(" / / / / / /  __/ /_/  __/ /_/ / /     /_____/  / /_/ / /_/ / / /  __/ /  / /_/ / / /_/ / /_/  __/");
  console.log("/_/ /_/ /_/\\___/\\__/\\___/\\____/_/              /_.___/\\____/_/_/\\___/_/  / .___/_/\\__,_/\\__/\\___/ ");
  console.log("                                                                        /_/                       ");
  console.log("Use one of the following commands:\n");

  getCreateMethods().forEach(function (command) {
    var description = fs.readFileSync(
      cliRoot + 'create/' + configuration.create_profile + '/' + command + '/info.txt',
      { encoding: "utf8" }
    );
    printCommand('create:' + command, description);
  });
  console.log();
}
